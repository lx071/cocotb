
# 数据类型——装饰器
这里以研究数据类型为例，进行说明。
```python
python端的bfm模块:
@cocotb.bfm(hdl={
    cocotb.bfm_vlog : cocotb.bfm_hdl_path(__file__, "hdl/spi_initiator_bfm.v"),
    cocotb.bfm_sv : cocotb.bfm_hdl_path(__file__, "hdl/spi_initiator_bfm.v"),
    }, has_init=True)
class SpiInitiatorBfm():
    .....
    @cocotb.bfm_export(cocotb.bfm_uint32_t)
    def _recv(self, rdat):
        self.rdat = rdat
        self.recv_ev.set()
        
    @cocotb.bfm_import(cocotb.bfm_uint32_t)
    def _send(self, dat):
        pass
```
这里面使用到了三个装饰器。这三个装饰器的描述写到`decorators.py`最后面。有四个类都为对象装饰器，具体可参考对象装饰器实现
+ bfm：识别bfm的装饰器，hdl用于识别hdl文件在哪
+ bfm_export：装饰器，用于指定需要被HDL环境调用的方法
+ bfm_import：装饰器，用于指定需要调用来自HDL环境的方法
+ bfm_param_int_t:用于注册数据类型，其中第一个参数表示位数，第二个参数表示是否为有符号数(sign);如果为sv，就有多种类型对应；如果为verilog，则只需输出reg类型的宽短

这三个类都用到bfm.py的方法，所以需要从这里继续看
# BFM管理器
BFM在python端的实现在bfms.py中，里面有几个方法：
+ register_bfm_type：用于注册bfm
+ register_bfm_import_info：用于将被装饰的方法放进全局列表中，方法的id设为当前列表长度
+ register_bfm_export_info:用于将被装饰的方法放进全局列表中，方法的id设为当前列表长度

有几个类用于描述数据结构：
+ BfmTypeInfo：里面包含了T——具体的BFM类，hdl——HDL文件和路径，import_info——需要被导入的方法列表，export_info——需要被导出的方法列表
+ BfmMethodParamInfo：用于描述单个数据类型的信息，包括参数名和参数类型
+ BfmMethodInfo：用于描述某BFM的方法信息，包括方法类型、参数类型
+ BfmInfo:

该文件最重要的就是BFM管理器`BfmMgr`,它被放在__init__.py的`177`行进行初始化，初始化时将verilog中注册的所有bfm都放进管理器
# 代码生成 bfmgen.py
这部分是代码生成。如果要单独理解该文件，只需根据main函数作为入口取模拟跑一遍即可。本质就是根据我们输入的参数是verilog还是system verilog生成对应的模版

如果联合起来运行，他会根据{cocotb_api_bfm_impl}来自动生成
```python
param_m = {
        "cocotb_bfm_api_impl": Template(cocotb_bfm_api_impl).safe_substitute(impl_param_m)
    }

return t.safe_substitute(param_m)
 ```

*bfmsgen.py*的代码比较清晰，只需根据main走一遍即可

# makefile
makefile用于指定整个项目如何运行；由于额外添加了一些C++文件，所以需要修改makefile里面的内容，使得在编译share的时候也需要把添加的文件进行`编译`
## makefile.inc
在1.3版本，它相当于一个头文件，每个makefile都会包含这个文件的信息。这里为了方便，就添加了一个`COCOTB_BFM_SOURCES`变量，用于没有指定`COCOTB_BFM_MODULES`时，他的BFM源文件在哪(没啥作用)
## makefile.sim
在83行，用于指定在运行前，首先调用我们的bfmgen.py来生成模版。这里的参数vlog可换成sv，看想要用vpi接口还是dpi接口
## simulators目录
这里主要介绍makefile.icarus, 因为其他仿真器是商用。我用不了

由于仿真器也需要根据makefile提供的变量，对对应的sorece文件进行编译和运行。所以需要添加上COCOTB_BFM_SOURCES变量，让生成的bfm.v文件也进行编译具体就改了这里（注意这里添加了两个$COCOTB_BFM_SOURECE）
这里的具体含义要看iverilog仿真器的命令，这个可后面再看
```
# Compilation phase
$(SIM_BUILD)/sim.vvp: $(SIM_BUILD) $(VERILOG_SOURCES) $(COCOTB_BFM_SOURCES) $(CUSTOM_COMPILE_DEPS)
	$(CMD) -o $(SIM_BUILD)/sim.vvp -D COCOTB_SIM=1 -s $(TOPLEVEL) $(COMPILE_ARGS) $(EXTRA_ARGS) $(COCOTB_BFM_SOURCES) $(VERILOG_SOURCES)

```
# lib目录
## simulator
这个目录定义了Python可以调用的一些方法，而这些方法是由c代码实现的。所以会在cocotb目录的py文件中会看到import simulator
主要添加了这些方法：
+ bfm_get_count： 注册到Cocotb的BFM数量
+ bfm_get_info： 返回特定BFM的信息,包括实例名和类名
+ bfm_send_msg： 发送消息给特定BFM
+ bfm_recv_msg： 接收信息，返回到Python端
## gpi目录
### cocotb_bfm_api.cpp
属于封装层，该文件给simulator.c调用

### GPIBFM.cpp
+ 私有属性：m_bfm_id——bfm的id；m_instname——仿真器环境的实例名；m_clsname——python环境的类名；m_notify_f——回调函数；*m_notify_data——传递给回调函数的用户数据；m_msg_queue——outbound的消息队列；*m_active_msg——正在执行的消息；*m_active_inbound_msg——inbound正在执行的消息；m_recv_msg_f；m_bfm_l——bfm列表

方法：
+ add_bfm(GpiBfm *bfm)： 添加一个bfm到列表中，bfm的id为当前列表大小
+ send_msg(GpiBfmMsg *msg)：指从python发送消息到hdl端口，把该msg放到队列，当msg可用时，则调用回调函数
+ claim_msg(): 从消息队列的头部取出，声明新的正在执行消息，返回当前msg的id

### GPIBFMMSG.cpp
用于管理传递的MSG，这里指调用的方法。这里有两个关键概念，outbound(Python->HDL)和inbound(HDL->Python)。所以outbound是指被import装饰器修饰的方法，用于在Python中调用HDL的任务；inbound同理
+ 构造函数参数：方法id，参数的数量，参数类型信息（包括参数类型和参数值）
+ 公共属性： 参数和参数类型
+ 私有属性：m_id——指定当前方法的id；*m_param_l——是一个消息参数列表（每个元素包括参数类型、参数值）；m_param_l_max——消息参数列表可容纳的最大值；m_param_l_idx——当前参数列表的索引，如果传入的参数数量不为-1，则索引值和列表最大值相同，如果传递的参数数量为-1，则创建一个没有内容的参数列表，此时索引为0；m_idx——调用get_param()方法时指定的索引值，每读取参数列表一次自加1

该类用于管理BFM的MSG，本质上是管理方法的参数，因此他创建了一个参数列表。这个列表中存放了参数，每个参数包含参数类型和参数值两个信息

该类提供了从列表中获取参数信息和往列表中添加参数信息两种主要的方法：
添加信息的方法：
+ add_param_ui：添加无符号整数的参数信息到列表
+ add_param_si ： 添加有符号整数的参数信息到列表
+ add_param：是其他三个方法的公共方法，添加参数信息到列表中
+ add_param_s ：添加字符串类型的参数信息到列表

获取参数的方法：
+ get_param： 获取当前m_idx的参数信息
+ get_param(uint32_t idx) ：获取指定idx的参数信息
+ get_param_ui：获取当前m_idx的无符号值
+ get_param_si：获取当前m_idx的有符号值
+ get_param_str：获取当前m_idx的字符串

# 总结
## 调用关系链
如果从装饰器类开始看 ——> 涉及到bfm.py的相关数据结构 ——> 里面调用了一些c++的代码，所以涉及到simulator.c --> simulator.c调用的是顶层封装的cocotb_bfm_api.cpp ——> 封装层实质上是调用了GPIBFM.cpp （是BFM管理器的真正实现）———>GPIBFM.cpp对消息也就是方法的信息进行了封装GPIMBFMMsg.cpp
## 从工作原理角度
首先是执行makefile文件——> 他会首先调用bfmgen.py生成模版。 ——> share目录相关文件以及 我们的.v文件编译 ——> 仿真开始 ——> 调用cocotb_bfm_api.cpp （这里涉及到GpiBfm/GpiBfmMsg/Vpi目录里的vpi_bfm_api）——>simulator.c ——> python端

模版格式如下：
```
//***************************************************************************
//* BFMs file for cocotb. 
//* Note: This file is generated by cocotb-bfmgen. Do Not Edit
//***************************************************************************
module spi_initiator_bfm #(
		parameter DAT_WIDTH=32
        ) (
        input				clk,
        output				sck,
        output reg			sdo,
        input				sdi,
        output[3:0]			csn
        );

	reg[3:0]				csn_r = 4'he;
	reg[DAT_WIDTH-1:0]		dat_in_r;
	reg[DAT_WIDTH-1:0]		dat_out_v;
	reg[DAT_WIDTH-1:0]		dat_out_r;
	reg[1:0]				xmit_en = 0;
	reg[7:0]				sck_div = 0;
	reg[7:0]				sck_div_cnt = 0;

	reg sck_r = 0;
	wire sck_i = (sck_div)?sck_r:clk;
	assign sck = (xmit_en)?sck_i:1'b1;
	assign csn = (xmit_en)?csn_r:{4{1'b1}};
	
	always @(posedge clk) begin
		if (sck_div == sck_div_cnt) begin
			sck_r <= ~sck_r;
			sck_div_cnt <= 0;
		end else begin
			sck_div_cnt <= sck_div_cnt + 1;
		end
	end

	// Transmit state machine
	reg      xmit_state = 0;
	reg[7:0] xmit_count = 0;
	always @(negedge sck) begin
		sdo <= (xmit_state)?dat_out_r[DAT_WIDTH-1]:dat_out_v[DAT_WIDTH-1];
		case (xmit_state) 
			0: begin
				dat_out_r <= {dat_out_v[DAT_WIDTH-2:0], 1'b0};
				xmit_state <= 1'b1;
				xmit_count <= 1;
			end
			1: begin
				dat_out_r <= {dat_out_r[DAT_WIDTH-2:0], 1'b0};
				if (xmit_count == DAT_WIDTH-1) begin
					xmit_state <= 0;
				end else begin
					xmit_count <= xmit_count + 1;
				end
			end
		endcase
	end
	
	// Receive state machine
	reg      recv_state = 0;
	reg[7:0] recv_count = 0;
	always @(posedge sck) begin
		dat_in_r <= {dat_in_r[DAT_WIDTH-2:0], sdi};
		case (recv_state)
			0: begin
				if (xmit_en) begin
					recv_count <= 1;
					recv_state <= 1;
				end
			end
			1: begin
				if (recv_count == DAT_WIDTH-1) begin
					recv_state <= 0;
					// Send the resulting data back. Note that
					// The final bit hasn't been shifted in, so we
					// handle that here
					xmit_en = xmit_en - 1;
		
					recv({dat_in_r[DAT_WIDTH-2:0], sdi});
				end else begin
					recv_count <= recv_count + 1;
				end
			end
		endcase
	end
	
	task send(reg[63:0]	data);
	begin
		xmit_en = xmit_en + 1;
		dat_out_v = data[DAT_WIDTH-1:0];

	end
	endtask

	
    // Auto-generated code to implement the BFM API


    reg signed[31:0]      bfm_id;
    event                 bfm_ev;
    reg signed[31:0]      bfm_msg_id;
    task recv(reg[32-1:0] rdat);
    begin
        $cocotb_bfm_begin_msg(bfm_id, 0);
        $cocotb_bfm_add_param_ui(bfm_id, rdat);
        $cocotb_bfm_end_msg(bfm_id);
    end
    endtask

    initial begin
      bfm_id = $cocotb_bfm_register("spi_bfms.spi_initiator_bfm.SpiInitiatorBfm", bfm_ev);
      while (1) begin
          bfm_msg_id = $cocotb_bfm_claim_msg(bfm_id);
          case (bfm_msg_id)
              0: begin
                  send(
                      $cocotb_bfm_get_param_ui32(bfm_id)
                      );
              end

              -1: begin
                  @(bfm_ev);
              end
          endcase
      end
    end
    


endmodule
```

可以看到它一开始会调用$cocotb_bfm_register 系统函数进行bfm的注册。

对于send方法的调用，其实他就是不断轮询，当发现$cocotb_bfm_claim_msg有正在执行的消息时，就会获取参数值然后调用send方法

而recv方法会调用相关系统函数，将参数传递到Python端

这个模版会使用到VPI接口，所以具体可看`share/lib/vpi` , DPI接口也是同理

# 结论

想要查看数据类型的真正转换，就要看simulator.c（涉及跨语言环境调用） 和 GpiBfmMsg.cpp（DPI接口）或vpi_bfm_api.cpp(vpi接口)

# 参考文档
有关DPI/VPI的说明文档
如：https://blog.csdn.net/Holden_Liu/article/details/113816222

http://www.sugawara-systems.com/veritak_sv_tutorial/dpi.htm

https://systemverilog.dev/9.html